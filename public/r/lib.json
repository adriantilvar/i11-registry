{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "lib",
  "type": "registry:lib",
  "title": "Library",
  "description": "Reusable code across the project",
  "dependencies": [
    "tailwind-merge"
  ],
  "files": [
    {
      "path": "src/lib/class-merge.ts",
      "content": "import { twMerge } from \"tailwind-merge\";\n\nexport type ClassValue =\n  | string\n  | Record<string, boolean>\n  | boolean\n  | null\n  | undefined;\n\nexport function cx(...inputs: ClassValue[]): string {\n  let result = \"\";\n\n  for (const input of inputs) {\n    if (!input || typeof input === \"boolean\") continue;\n\n    if (typeof input === \"string\") {\n      result += `${input} `;\n      continue;\n    }\n\n    for (const [key, value] of Object.entries(input)) {\n      if (value) result += `${key} `;\n    }\n  }\n\n  return result.trimEnd();\n}\n\nexport function cn(...inputs: ClassValue[]): string {\n  return twMerge(cx(...inputs));\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/create-variants.ts",
      "content": "import { type ClassValue, cx } from \"./class-merge\";\n\n/**\n * Type utility to extract the props type from a variant selection function.\n *\n * @template T - A function that returns a string.\n */\nexport type VariantProps<T> = T extends (props: infer P) => string ? P : never;\n\ntype TConfig = {\n  /**\n   * Contains the classes that will always be applied.\n   */\n  base: ClassValue;\n\n  /**\n   * Variant-specific classes. Must include a 'default' which is used as a fallback.\n   */\n  variant: { default: ClassValue } & Record<string, ClassValue>;\n\n  /**\n   * Size-specific classes. Must include a 'default' which is used as a fallback.\n   */\n  size: { default: ClassValue } & Record<string, ClassValue>;\n};\n\n/**\n * Props that can be passed to a variant selection function.\n * These map to the keys of the `variant` and `size` options.\n *\n * @template S - Configuration object defining variant options.\n */\ntype TSelectionProps<S extends TConfig> = Partial<{\n  [K in keyof Omit<TConfig, \"base\">]: keyof S[K];\n}>;\n\n/**\n * Creates a variant selection function that composes class names\n * based on a config object and a set of selected props.\n *\n * @template T - An object containing `base`, `variant`, and `size` mappings.\n * @param config - The configuration object defining base, variant, and size classes.\n * @returns A function that optionally takes `variant` and `size` props and returns a combined class string.\n *\n * @example\n * const button = createVariants({\n *   base: \"inline-flex\",\n *   variant: { default: \"bg-gray-200\", primary: \"bg-blue-500\" },\n *   size: { default: \"px-4 py-2\", sm: \"px-2 py-1\" }\n * });\n *\n * button(); // -> \"inline-flex bg-gray-200 px-4 py-2\"\n * button({ variant: \"primary\", size: \"sm\" }); // -> \"inline-flex bg-blue-500 px-2 py-1\"\n */\nexport const createVariants =\n  <T extends TConfig>(config: T) =>\n  (props: TSelectionProps<T>) =>\n    cx(\n      config.base,\n      config.variant[props?.variant ? props.variant : \"default\"],\n      config.size[props?.size ? props.size : \"default\"],\n    );\n",
      "type": "registry:lib"
    }
  ]
}