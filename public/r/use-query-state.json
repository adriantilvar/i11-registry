{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-query-state",
  "type": "registry:hook",
  "title": "Query Strings Hook",
  "description": "Hooks for managing URL query parameters in Next.js",
  "dependencies": [
    "zod@4.1.12"
  ],
  "registryDependencies": [
    "https://i11-registry.vercel.app/r/lib.json"
  ],
  "files": [
    {
      "path": "registry/hooks/use-query-state.ts",
      "content": "import { usePathname, useRouter, useSearchParams } from \"next/navigation\";\nimport { useEffect, useRef } from \"react\";\nimport type z from \"zod\";\nimport type { NonEmptyArray, UniqueArray } from \"@/types/array\";\nimport type { Maybe } from \"@/types/base\";\n\ntype UseQueryStateOptions = Partial<{\n  /**\n   * Fallback value when query parameter is missing, empty, or fails validation.\n   *\n   * @remarks\n   * - used when schema validation fails and `onParseError` is `\"fallback\"` (default)\n   * - without this, empty/invalid values remove the query parameter entirely\n   */\n  defaultValue: string;\n  /**\n   * Zod schema for validating query parameter values.\n   *\n   * @remarks\n   * - must return a string to maintain URLSearchParams compatibility.\n   *\n   * @example\n   * ```tsx\n   * // Enum validation\n   * schema: z.enum(['small', 'medium', 'large'])\n   *\n   * // Number coercion to string\n   * schema: z.coerce.number().min(1).transform(String)\n   *\n   * // Custom validation\n   * schema: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/)\n   * ```\n   */\n  schema: z.ZodType<string>;\n  /**\n   * Behavior when schema validation fails (defaults to `\"fallback\"`).\n   *\n   * @remarks\n   * - `\"fallback\"` - use `defaultValue` if provided, otherwise remove parameter\n   * - `\"remove\"` - always remove the parameter on validation failure\n   */\n  onParseError: \"fallback\" | \"remove\";\n}>;\n\n/**\n * A hook to manage a single URL query parameter.\n *\n * @param key - The name of the query parameter to track\n * @param options - Configuration options with the shape of `UseQueryStateOptions`\n * @returns A tuple containing the current value and a setter function (client-side navigation)\n *\n * @example\n * ```tsx\n * // Basic usage\n * const [page, setPage] = useQueryState('page');\n *\n * // With default value\n * const [sort, setSort] = useQueryState('sort', {\n *   defaultValue: 'name'\n * });\n *\n * // With validation schema\n * const [status, setStatus] = useQueryState('status', {\n *   defaultValue: 'active'\n *   schema: z.enum(['active', 'inactive']),\n * });\n *\n * // Setter usage\n * setStatus('inactive');\n * ```\n *\n * @remarks\n * - implementation is not memoized (assumes React Compiler is used)\n * - `queryState` will be `null` if no query parameter exists and no default is provided\n * - query parameter deduplication (e.g. `step=goal&step=persona`) is out of scope for this\n * hook; it happens to deduplicate query strings sometimes, but it's complete/reliable\n */\nexport function useQueryString<const K extends string>(\n  key: K,\n  options?: UseQueryStateOptions,\n): [Maybe<string>, (value: string) => void] {\n  const isMounted = useRef(false);\n  const router = useRouter();\n  const pathname = usePathname();\n  const searchParams = useSearchParams();\n\n  const queryString = searchParams.get(key);\n\n  function setQueryString(value: string) {\n    router.replace(\n      `${pathname}?${createSearchParams({\n        update: [key, value],\n        searchParams,\n        options,\n      })}`,\n    );\n  }\n\n  useEffect(() => {\n    const hasParam = searchParams.has(key);\n    const paramValue = searchParams.get(key);\n\n    if (!options || Object.keys(options).length === 0) {\n      if (hasParam && !paramValue) {\n        setQueryString(\"\");\n      }\n      return;\n    }\n\n    const hasDefaultValue = !!options.defaultValue;\n    const hasSchema = !!options.schema;\n\n    if (\n      (!isMounted.current &&\n        hasDefaultValue &&\n        paramValue !== options.defaultValue) ||\n      (!isMounted.current && !hasDefaultValue && hasSchema) ||\n      (hasParam && !paramValue) ||\n      (!hasParam && hasDefaultValue)\n    ) {\n      if (!isMounted.current) {\n        isMounted.current = true;\n      }\n\n      setQueryString(paramValue ?? \"\");\n    }\n  }, [key, options, searchParams, setQueryString]);\n\n  return [queryString, setQueryString] as const;\n}\n\n/**\n *  A hook to manage multiple URL query parameters.\n *\n * @param keys Array of unique query parameter names to track\n * @param options Per-key configuration options, each having the shape of `UseQueryStringOptions`\n * @returns A tuple containing an object of current values and a setter function (client-side navigation)\n *\n * @example\n * ```tsx\n * // Basic usage\n * const [queries, setQuery] = useQueriesState(['sort', 'filter']);\n * // queries: { sort: string | null, filter: string | null }\n *\n * // With per-key options\n * const [queries, setQuery] = useQueriesState(['page', 'sort'], {\n *   page: { defaultValue: '1', schema: z.coerce.number().min(1).transform(String) },\n *   sort: { defaultValue: 'name' }\n * });\n *\n * // Setter usage\n * setQuery('page', '2');\n * ```\n *\n * @remarks\n * - implementation is not memoized (assumes React Compiler is used)\n * - updates are batched when multiple parameters change simultaneously\n * - duplicate keys in the array are not allowed\n * - query parameter deduplication (e.g. `step=goal&step=persona`) is out of scope; it happens to deduplicate * query strings in some instances, but should not be counted on\n */\nexport function useQueryStrings<const K extends NonEmptyArray<string>>(\n  keys: UniqueArray<K>,\n  options?: Partial<Record<K[number], UseQueryStateOptions>>,\n): [Record<K[number], Maybe<string>>, (key: K[number], value: string) => void] {\n  const isMounted = useRef(false);\n  const router = useRouter();\n  const pathname = usePathname();\n  const searchParams = useSearchParams();\n\n  const updateSearchParams = (updates: NonEmptyArray<[K[number], string]>) => {\n    if (!updates.length) return;\n\n    router.replace(\n      `${pathname}?${createSearchParamsWithMany({\n        updates,\n        searchParams,\n        options,\n      }).toString()}`,\n    );\n  };\n\n  function getSearchParamsUpdates(): Array<[K[number], string]> {\n    const paramUpdates: Array<[K[number], string]> = [];\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const hasParam = searchParams.has(key);\n      const paramValue = searchParams.get(key);\n      const paramOptions: Maybe<UseQueryStateOptions> = options?.[key];\n\n      if (!paramOptions || Object.keys(paramOptions).length === 0) {\n        if (hasParam && !paramValue) {\n          paramUpdates.push([key, \"\"]);\n        }\n        continue;\n      }\n\n      const hasDefaultValue = !!paramOptions.defaultValue;\n      const hasSchema = !!paramOptions.schema;\n\n      if (\n        (!isMounted.current &&\n          hasDefaultValue &&\n          paramValue !== paramOptions.defaultValue) ||\n        (!isMounted.current && !hasDefaultValue && hasSchema) ||\n        (hasParam && !paramValue) ||\n        (!hasParam && hasDefaultValue)\n      ) {\n        paramUpdates.push([key, paramValue ?? \"\"]);\n      }\n    }\n\n    return paramUpdates;\n  }\n\n  useEffect(() => {\n    const updates = getSearchParamsUpdates();\n\n    if (!isMounted.current) {\n      isMounted.current = true;\n    }\n\n    if (updates.length > 0) {\n      updateSearchParams(updates as NonEmptyArray<[K[number], string]>);\n    }\n  }, [getSearchParamsUpdates, updateSearchParams]);\n\n  const queryStrings = Object.fromEntries(\n    keys.map((key) => [key, searchParams.get(key)]),\n  ) as Record<K[number], Maybe<string>>;\n\n  function setQueryString(key: K[number], value: string) {\n    updateSearchParams([[key, value]]);\n  }\n\n  return [queryStrings, setQueryString] as const;\n}\n\nfunction updateQueryState<Key extends string, Value extends string>({\n  key,\n  value,\n  searchParams,\n  options,\n}: {\n  key: Key;\n  value: Value;\n  searchParams: URLSearchParams;\n  options?: UseQueryStateOptions;\n}): void {\n  if (!options) {\n    if (value) {\n      searchParams.set(key, value);\n    } else {\n      searchParams.delete(key);\n    }\n    return;\n  }\n\n  const { defaultValue, schema, onParseError = \"fallback\" } = options;\n  const shouldFallback = onParseError === \"fallback\" && !!defaultValue;\n  const shouldRemove = onParseError === \"remove\" || !defaultValue;\n\n  if (schema) {\n    const validationResult = schema.safeParse(value);\n\n    if (validationResult.success) {\n      searchParams.set(key, validationResult.data);\n      return;\n    }\n\n    if (shouldFallback) {\n      searchParams.set(key, defaultValue);\n      return;\n    }\n\n    if (shouldRemove) {\n      searchParams.delete(key);\n      return;\n    }\n  }\n\n  if (!value && shouldFallback) {\n    searchParams.set(key, defaultValue);\n    return;\n  }\n\n  if (!value && shouldRemove) {\n    searchParams.delete(key);\n    return;\n  }\n\n  if (value) {\n    searchParams.set(key, value);\n  }\n}\n\nfunction createSearchParamsWithMany<Key extends string, Value extends string>({\n  updates,\n  searchParams,\n  options,\n}: {\n  updates: NonEmptyArray<[Key, Value]>;\n  searchParams: URLSearchParams;\n  options?: Partial<Record<Key, UseQueryStateOptions>>;\n}): URLSearchParams {\n  const urlSearchParams = new URLSearchParams(searchParams);\n\n  for (let i = 0; i < updates.length; i++) {\n    const [key, value] = updates[i];\n    updateQueryState({\n      key,\n      value,\n      searchParams: urlSearchParams,\n      options: options?.[key],\n    });\n  }\n\n  return urlSearchParams;\n}\n\nfunction createSearchParams<Key extends string, Value extends string>({\n  update,\n  searchParams,\n  options,\n}: {\n  update: [Key, Value];\n  searchParams: URLSearchParams;\n  options?: UseQueryStateOptions;\n}): URLSearchParams {\n  const urlSearchParams = new URLSearchParams(searchParams);\n  const [key, value] = update;\n  updateQueryState({\n    key,\n    value,\n    searchParams: urlSearchParams,\n    options,\n  });\n\n  return urlSearchParams;\n}\n",
      "type": "registry:hook"
    }
  ]
}